import { exec } from 'child_process';
import { promisify } from 'util';
import { writeFileSync, readFileSync, mkdtempSync, rmSync, readdirSync } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';
import { logger } from './logger';
import { OCRResult } from '../types/layout-types';

const execAsync = promisify(exec);

export class YomitokuClient {
  constructor() {
    // yomitokuコマンドの存在確認
    this.checkYomitokuAvailability();
  }

  async performOCR(imageBuffer: Buffer): Promise<OCRResult> {
    let tempDir: string | null = null;
    let imagePath: string | null = null;

    try {
      logger.info('Starting yomitoku OCR processing');

      // 一時ディレクトリの作成
      tempDir = mkdtempSync(join(tmpdir(), 'kusa-anki-yomitoku-'));
      
      // 一時画像ファイルの作成
      imagePath = join(tempDir, 'temp-image.png');
      writeFileSync(imagePath, imageBuffer);

      // yomitoku実行
      const outputDir = join(tempDir, 'output');
      const markdownContent = await this.executeYomitoku(imagePath, outputDir);

      // Markdown解析
      const ocrResult = this.parseMarkdownResult(markdownContent);

      logger.info('Yomitoku OCR processing completed');
      return ocrResult;
    } catch (error) {
      logger.error('Failed to perform yomitoku OCR:', error);
      throw error;
    } finally {
      // 一時ファイルのクリーンアップ
      if (tempDir) {
        try {
          rmSync(tempDir, { recursive: true, force: true });
        } catch (cleanupError) {
          logger.warn('Failed to cleanup temp directory:', cleanupError);
        }
      }
    }
  }

  private async checkYomitokuAvailability(): Promise<void> {
    try {
      await execAsync('which yomitoku');
    } catch (error) {
      throw new Error(
        'yomitoku command not found. Please install yomitoku before using this feature. ' +
        'Visit: https://github.com/jamsinclair/yomitoku for installation instructions.'
      );
    }
  }

  private async executeYomitoku(imagePath: string, outputDir: string): Promise<string> {
    try {
      // yomitokuコマンドの実行
      const command = `yomitoku "${imagePath}" -f md -o "${outputDir}"`;
      logger.debug(`Executing command: ${command}`);
      
      const { stdout, stderr } = await execAsync(command);
      
      if (stderr) {
        logger.warn('yomitoku stderr:', stderr);
      }
      
      if (stdout) {
        logger.debug('yomitoku stdout:', stdout);
      }

      // 生成されたMarkdownファイルを読み込み
      const markdownFiles = this.findMarkdownFiles(outputDir);
      if (markdownFiles.length === 0) {
        throw new Error('No markdown files generated by yomitoku');
      }

      // 最初のMarkdownファイルを読み込み（通常は1つだけ生成される）
      const markdownPath = markdownFiles[0];
      const markdownContent = readFileSync(markdownPath, 'utf-8');
      
      logger.debug(`Read markdown from: ${markdownPath}`);
      return markdownContent;
    } catch (error) {
      if (error instanceof Error && error.message.includes('Command failed')) {
        throw new Error(`yomitoku command failed: ${error.message}`);
      }
      throw error;
    }
  }

  private findMarkdownFiles(outputDir: string): string[] {
    try {
      const files = readdirSync(outputDir);
      return files
        .filter((file: string) => file.endsWith('.md'))
        .map((file: string) => join(outputDir, file));
    } catch (error) {
      logger.error('Failed to read output directory:', error);
      return [];
    }
  }

  private parseMarkdownResult(markdownContent: string): OCRResult {
    try {
      const lines = markdownContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);
      
      if (lines.length === 0) {
        return {
          plantName: 'unknown',
          fullText: ''
        };
      }

      // 植物名の抽出：複数のパターンを試行
      let plantName = 'unknown';
      
      // パターン1: "科"の前の行を探す（最も確実）
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.includes('科') && line.includes('属') && i > 0) {
          // 前の行が植物名の可能性が高い
          const previousLine = lines[i - 1];
          if (previousLine && !previousLine.startsWith('>>') && !previousLine.startsWith('#') && 
              !previousLine.includes('分布') && !previousLine.includes('見わけ')) {
            plantName = previousLine;
            break;
          }
        }
      }
      
      // パターン2: 見出し（# で始まる行）を植物名とする
      if (plantName === 'unknown') {
        const headingLine = lines.find(line => line.startsWith('# '));
        if (headingLine) {
          plantName = headingLine.replace(/^#\s*/, '').trim();
        }
      }
      
      // パターン3: 最初の適切な行を植物名とする
      if (plantName === 'unknown') {
        for (const line of lines) {
          if (line && !line.startsWith('>>') && !line.startsWith('#') && 
              !line.includes('科') && !line.includes('分布') && 
              !line.includes('見わけ') && !line.includes('<br>') &&
              line.length >= 2 && line.length <= 20) {
            plantName = line;
            break;
          }
        }
      }

      // 説明文の抽出（Markdown記号を除去した全テキスト）
      const fullText = lines
        .join('\n')
        .replace(/^#\s*/gm, '') // 見出し記号を除去
        .replace(/<br>/g, '\n') // <br>タグを改行に変換
        .replace(/\*\*(.*?)\*\*/g, '$1') // 太字記号を除去
        .replace(/\*(.*?)\*/g, '$1') // イタリック記号を除去
        .trim();

      return {
        plantName: plantName || 'unknown',
        fullText: fullText || ''
      };
    } catch (error) {
      logger.error('Failed to parse markdown result:', error);
      logger.debug('Raw markdown content:', markdownContent);
      
      return {
        plantName: 'unknown',
        fullText: markdownContent || ''
      };
    }
  }
}